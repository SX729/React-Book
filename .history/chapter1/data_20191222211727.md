## 1. React 数据流
&emsp;&emsp;在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。state 与 props 是 React 组件中最重要的概念。如果顶层组件初始化 props，那么 React 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而 state 只关心每个组件自己内部的状态，这些状态只能在组件内改变。**把组件看成一个函数，那么它接受了 props 作为参数，内部由 state作为函数的内部参数，返回一个 Virtual DOM 的实现.**
## 2. state
&emsp;&emsp;React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。
&emsp;&emsp;React组件添加一个类构造函数来初始化状态 this.state：
```
    class CreateComponent extends PureComponent {
      constructor(props) {
        super(props)
        this.state = {
        }
      }
    }
```
&emsp;&emsp;当组件内部数据改变，需要更新组件时，使用库内置的 setState 方法，将该组件尝试重新渲染。不要直接去操作this.state， 这样会造成不必要的性能问题和隐患。setState 是一个异步方法，触发一次组件的更新来引发重绘，注意：多次 setState 函数调用产生的效果会合并。

    重绘指的就是引起 React 的更新生命周期函数4个函数：
    shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）
    componentWillUpdate（被调用时this.state没有更新）
    render（被调用时this.state得到更新）
    componentDidUpdate

  若在state状态改变后需要做些操作，则需要写在setState回调函数内：
```
    this.state = {foo: 2};
    this.setState({foo: 123}, ()=> {
    console.log(foo);
    // 123
    });
```
注意:通过 addEventListener || setTimeout/setInterval 的方式处理的则会同步更新。但是还是尽量避免直接使用。
```
    componentDidMount() {
      this.setState({val: this.state.val + 1});
      console.log('第 1 次 log:', this.state.val);
      this.setState({val: this.state.val + 1});
      console.log('第 2 次 log:', this.state.val);

    setTimeout(() => {
      this.setState({val: this.state.val + 1});
      console.log('第 3 次 log:', this.state.val);   
      this.setState({val: this.state.val + 1});
      console.log('第 4 次 log:', this.state.val); 
    }, 0);
    }
```
前两次没有更新state, 输出两个0。
后面两次会同步更新， 分别输出2， 3；